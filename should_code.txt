sum에 최대 사탕 개수 for문으로 정리
절반으로 나눈값이 nums의 길이보다 작거나 같으면 answer = 그 값
절반으로 나눈 값이 nums의 길이보다 크면 answer = nums의 길이

먹을 수 있는 사탕의 개수    가지고 있는 사탕의 개수

nums오름차순 정리
for문으로 nums돌면서 최소차 구하기
for문으로 nums돌면서 최소차와 같은 쌍 구해서 answer로 반환

nums오름차순 정리
for문 안에 while문으로 nums[i]부터 다음 수까지 더해서 target값보다 크면 다음으로
그전에 target값과 같은 합을 찾으면 그 합 answer로 리턴

box[1]번으로 내림차순 정렬
앞에서부터 sum += 하고 

0부터 시작하는 선 중에서 제일 긴 선을 선택
해당선의 마지막 번호를 포함한 선들 중에서 가장 길이가 긴 선 선택 반복

앞이 0인 선들중에서 가장 긴석

7n2
이진트림 탐색 -> weight값보다 큰 값중에서 가장 작은값의 인덱스 번호를 구하고
오름차순이므로 그 인덱스 값을 반환

7n3
선형탐색x -> 이진트리 탐색, mid값 설정, mid값이 인덱스 값보다 크거나 작을 경우
left, right 이동
lower bound search사용

8n1
stack활용
(가 입력됬을 떄 +1
)가 입력됬을 떄 -1
만약 0인데 -1이 입력되면 no 리턴
최종 결과가 0이면 yes 0이 아니면 no리턴

8n2
stack활용
문자열이 추가될 때마다 append
#일 때는 pop
다끝나고 남은 문자열 리턴

8n3
stack활용
문자열 차례대로 append
2번째 문제부터 전 값과 비교해서 같으면 둘다 삭제, 아니면 append
최종적으로 남는 결과 리턴

8n4
stack활용
문자열 차례대로 append
stack의 길이가 2이상이고 제일 최근 2개의 값이 1과 2 이고 i가 1일 떄
최근 2개 값 pop하고 count += 1

8n5
que활용

9n2
첫째항과 두번째 항을 1로 미리 설정
DFS(5) = DFS(4) + DFS(3)
       = DFS(3) + DFS(3) + DFS(2) + DFS(1)

9n3
탐색하면서 1이 발견되면 범위 안에서 상하좌우 탐색 -> 1이 발견되면 또 탐색(탐색한 공간 체크)
					     -> 0이 발견되면 탐색 중지(탐색한 공간 체크)

9n4
이중포문 돌면서 1을 탐색 -> 1탐색 한곳 발견하면 탐색한 공간 0으로 변환 후 4방향 탐색 + count += 1
->4방향 탐색 후 1탐색 되면 반복, 없으면 현재 count를 answer에 append후 count를 0으로 초기화

10n1
BFS활용

10n2

11n1
그래프 인접리스트 무방향그래프 활용
인접리스트 인덱스 1번부터 시작
인덱스 1번의 값들을 DFS돌림(한번 방문한 것들은 체크)

11n2
edges의 길이가 존재하는 첫번쨰 인덱스 부터 시작해서 끝나면 다음으로 길이가 존재하고 체크안되어있는
인덱스 시작

