sum에 최대 사탕 개수 for문으로 정리
절반으로 나눈값이 nums의 길이보다 작거나 같으면 answer = 그 값
절반으로 나눈 값이 nums의 길이보다 크면 answer = nums의 길이

먹을 수 있는 사탕의 개수    가지고 있는 사탕의 개수

nums오름차순 정리
for문으로 nums돌면서 최소차 구하기
for문으로 nums돌면서 최소차와 같은 쌍 구해서 answer로 반환

nums오름차순 정리
for문 안에 while문으로 nums[i]부터 다음 수까지 더해서 target값보다 크면 다음으로
그전에 target값과 같은 합을 찾으면 그 합 answer로 리턴

box[1]번으로 내림차순 정렬
앞에서부터 sum += 하고 

0부터 시작하는 선 중에서 제일 긴 선을 선택
해당선의 마지막 번호를 포함한 선들 중에서 가장 길이가 긴 선 선택 반복

앞이 0인 선들중에서 가장 긴석

7n2
이진트림 탐색 -> weight값보다 큰 값중에서 가장 작은값의 인덱스 번호를 구하고
오름차순이므로 그 인덱스 값을 반환

7n3
선형탐색x -> 이진트리 탐색, mid값 설정, mid값이 인덱스 값보다 크거나 작을 경우
left, right 이동
lower bound search사용

8n1
stack활용
(가 입력됬을 떄 +1
)가 입력됬을 떄 -1
만약 0인데 -1이 입력되면 no 리턴
최종 결과가 0이면 yes 0이 아니면 no리턴

8n2
stack활용
문자열이 추가될 때마다 append
#일 때는 pop
다끝나고 남은 문자열 리턴

8n3
stack활용
문자열 차례대로 append
2번째 문제부터 전 값과 비교해서 같으면 둘다 삭제, 아니면 append
최종적으로 남는 결과 리턴

8n4
stack활용
문자열 차례대로 append
stack의 길이가 2이상이고 제일 최근 2개의 값이 1과 2 이고 i가 1일 떄
최근 2개 값 pop하고 count += 1

8n5
que활용

9n2
첫째항과 두번째 항을 1로 미리 설정
DFS(5) = DFS(4) + DFS(3)
       = DFS(3) + DFS(3) + DFS(2) + DFS(1)

9n3
탐색하면서 1이 발견되면 범위 안에서 상하좌우 탐색 -> 1이 발견되면 또 탐색(탐색한 공간 체크)
					     -> 0이 발견되면 탐색 중지(탐색한 공간 체크)

9n4
이중포문 돌면서 1을 탐색 -> 1탐색 한곳 발견하면 탐색한 공간 0으로 변환 후 4방향 탐색 + count += 1
->4방향 탐색 후 1탐색 되면 반복, 없으면 현재 count를 answer에 append후 count를 0으로 초기화

10n1
BFS활용

10n2

11n1
그래프 인접리스트 무방향그래프 활용
인접리스트 인덱스 1번부터 시작
인덱스 1번의 값들을 DFS돌림(한번 방문한 것들은 체크)

11n2
edges의 길이가 존재하는 첫번쨰 인덱스 부터 시작해서 끝나면 다음으로 길이가 존재하고 체크안되어있는
인덱스 시작

swea
1859.
제일 비싼 날 전날 까지는 계속 사서 제일 비싼 날 팔기(팔고 나면 그 길이 삭제 후 리스트 재반환?)
->그 다음이 있다면 그 다음 범위에서 가장 비싼 날 전까지 사서 팔기
->반복
->길이가 0이 될때까지?
=====================
max값 찾기
max값 찾은 인덱스 전까지
남은 인덱스 들을 빈리스트에 추가 후 반환


1928.


2007.
반복되는것의 기준 -> 찾는 영역을 1에서 시작해서 1씩 증가시키며 탐색
똑같은 문자열이 발견됬을시 탐색 영역 길이를 반환

같은 문자가 나오면 나온문자까지의 문자들과 그 길이만큼 다음 문자들이 같은지 아닌지 판단
맞으면 마디길이 반환 아니면 진행

2005.
파스칼의 삼각형
B[0] = A[0]
B[1] = A[0] + A[1]
B[2] = A[1] + A[2]
B[3] = A[2]

2001.
m=2 n=5
m-n+1

m=3 n=7