sum에 최대 사탕 개수 for문으로 정리
절반으로 나눈값이 nums의 길이보다 작거나 같으면 answer = 그 값
절반으로 나눈 값이 nums의 길이보다 크면 answer = nums의 길이

먹을 수 있는 사탕의 개수    가지고 있는 사탕의 개수

nums오름차순 정리
for문으로 nums돌면서 최소차 구하기
for문으로 nums돌면서 최소차와 같은 쌍 구해서 answer로 반환

nums오름차순 정리
for문 안에 while문으로 nums[i]부터 다음 수까지 더해서 target값보다 크면 다음으로
그전에 target값과 같은 합을 찾으면 그 합 answer로 리턴

box[1]번으로 내림차순 정렬
앞에서부터 sum += 하고 

0부터 시작하는 선 중에서 제일 긴 선을 선택
해당선의 마지막 번호를 포함한 선들 중에서 가장 길이가 긴 선 선택 반복

앞이 0인 선들중에서 가장 긴석

7n2
이진트림 탐색 -> weight값보다 큰 값중에서 가장 작은값의 인덱스 번호를 구하고
오름차순이므로 그 인덱스 값을 반환

7n3
선형탐색x -> 이진트리 탐색, mid값 설정, mid값이 인덱스 값보다 크거나 작을 경우
left, right 이동
lower bound search사용

8n1
stack활용
(가 입력됬을 떄 +1
)가 입력됬을 떄 -1
만약 0인데 -1이 입력되면 no 리턴
최종 결과가 0이면 yes 0이 아니면 no리턴

8n2
stack활용
문자열이 추가될 때마다 append
#일 때는 pop
다끝나고 남은 문자열 리턴

8n3
stack활용
문자열 차례대로 append
2번째 문제부터 전 값과 비교해서 같으면 둘다 삭제, 아니면 append
최종적으로 남는 결과 리턴

8n4
stack활용
문자열 차례대로 append
stack의 길이가 2이상이고 제일 최근 2개의 값이 1과 2 이고 i가 1일 떄
최근 2개 값 pop하고 count += 1

8n5
que활용

9n2
첫째항과 두번째 항을 1로 미리 설정
DFS(5) = DFS(4) + DFS(3)
       = DFS(3) + DFS(3) + DFS(2) + DFS(1)

9n3
탐색하면서 1이 발견되면 범위 안에서 상하좌우 탐색 -> 1이 발견되면 또 탐색(탐색한 공간 체크)
					     -> 0이 발견되면 탐색 중지(탐색한 공간 체크)

9n4
이중포문 돌면서 1을 탐색 -> 1탐색 한곳 발견하면 탐색한 공간 0으로 변환 후 4방향 탐색 + count += 1
->4방향 탐색 후 1탐색 되면 반복, 없으면 현재 count를 answer에 append후 count를 0으로 초기화

10n1
BFS활용

10n2

11n1
그래프 인접리스트 무방향그래프 활용
인접리스트 인덱스 1번부터 시작
인덱스 1번의 값들을 DFS돌림(한번 방문한 것들은 체크)

11n2
edges의 길이가 존재하는 첫번쨰 인덱스 부터 시작해서 끝나면 다음으로 길이가 존재하고 체크안되어있는
인덱스 시작

swea
1859.
제일 비싼 날 전날 까지는 계속 사서 제일 비싼 날 팔기(팔고 나면 그 길이 삭제 후 리스트 재반환?)
->그 다음이 있다면 그 다음 범위에서 가장 비싼 날 전까지 사서 팔기
->반복
->길이가 0이 될때까지?
=====================
max값 찾기
max값 찾은 인덱스 전까지
남은 인덱스 들을 빈리스트에 추가 후 반환


1928.


2007.
반복되는것의 기준 -> 찾는 영역을 1에서 시작해서 1씩 증가시키며 탐색
똑같은 문자열이 발견됬을시 탐색 영역 길이를 반환

같은 문자가 나오면 나온문자까지의 문자들과 그 길이만큼 다음 문자들이 같은지 아닌지 판단
맞으면 마디길이 반환 아니면 진행

2005.
파스칼의 삼각형
B[0] = A[0]
B[1] = A[0] + A[1]
B[2] = A[1] + A[2]
B[3] = A[2]

2001.
m=2 n=5
m-n+1

m=3 n=7

1989.
짝수인 경우 슬라이싱으로 절반 나누어서 비교후 판단
홀수인 경우 중간값을 찾아서 중간값에서 가까운 순으로 판단
1234567
0123456

1986.
for문으로 홀짝 나누어서 fi문으로 케이스 비교

1984.
최대수 최소수는 max, min함수로 제거한 다음 리스트에 있는 나머지
값들의 평균값을 구해서 풀력

1983.
입력받은 학생수대로 세 점수를 더해서 빈 리스트에 추가하는 작업
sort()정렬 후 1/10범위만큼 if 문으로 해당 과제점수 부여
20 12

1979.
이중포문으로 하나하나 탐색
1을 발견하면 상하좌우 직선길이 탐색
탐색조선은 직선 방향 반대 방향쪽 한칸은 무조건 0이어야하고
길이만큼 직선 방향에 있는 숫자는 모두 1이어야하고
그 다음 한칸은 0이어야한다.

1973.
리스트로 저장해서 인덱스가 0, 2는 시각 1, 3은 분이다
각각 더하고 시를 더했을 때 12보다 크거나 같으면 -12를 해주고
분을 더했을 때 60보다 크면 -60을 해주고 시 +1

1974.
행탐색, 열탐색
3x3 for문으로 돌아가면서 빈리스트에 하나씩 추가하면서 겹치는 숫자가
있으면 0출력 break

1970.
입력받은 값이 5만 보다 크면 while문으로 N -10000 * i로 돌려서 값이
5만보다 작아질떄까지 실행
반복

1966.

1961

00 01 02   20 10 00
10 11 12   21 11 01
20 21 22   22 12 02

1959.
for문으로 긴 것을 기준으로 앞에서부터 3개씩 서로 곱해서 더한 값을
answer에 저장 후 마지막에 큰 값 반환

1954.
윗줄 입력 후 (반시계방향으로 90도 돌린 후 윗 줄채우기)반복

1 1
2 3
3 5
4 7
5 9
2m-1

1   1
2    2 1 1
3   3 2 2 1 1
4   4 3 3 2 2 1 1
5   5 4 4 3 3 2 2 1 1

0으로 이루어진 m*m행렬
윗줄부터 직선탐색
다음 탐색 공간이 벽이나 0이 아닌 숫자이면 시계방향으로 방향 꺾기
2 3 0 1 | 2 3 0 1 | 2 3 0 1 |

x = 0 y = 2 

1948.
월별 일수를 월을 인덱스로 한다름 일수를 적용
3 20   7 7 
사이에 있을 월의 일수 먼저 더하기
그 다음 뒤에 월의 일수를 더하고 앞의 월의 일수에서 입력받은 일수 뺴고 더하기
3 20  4 2

1946.
입력받은 문자들을 전부 붙여서 하나의 str로 저장


1945.
첫번째 값으로 나누어서 나머지가 없으면 a += 1
다시 첫 번째 값으로 나누기 반복
나머지가 있으면 두번째 값으로 이동

1940.
현재속도 변수 = 0
0.현재속도유지 -> 이동거리 = 이동거리 + 현재속도
1.가속 -> 현재속도 = 현재속도 + 가속도값
2.감속 -> 현재속도 = 현재속도 - 감속도값

1928.
엔코딩문제?? d2난이도?

1288.
빈리스트생성, str인풋, str의 인덱스로 빈리스트에 하나씩 추가하는데
만약에 이미 들어있으면 넘어가고
빈리스트의 길이가 10이 되면 멈추고 현재KN출력

1284.
P*W    Q(W<=R) or Q+S*W(W>R)
W를 기준으로 두가지 케이스로 if실행
1)W<=R
p*N     Q
2)W>R
p*N  Q+S*N

1204.
입력된 수를 인덱스로 활용
101길이의 0으로 채운 빈 리스트 생성
for문으로 해당 수가 나올때 마다 인덱스 += 1

=======================================
swea d3
=======================================

17937.
출제의도파악

17642.최대 조작 횟수
case1 처음부터 두 변수의 차이가 1이면 -1출력
case2 변수의 차이가 짝수면 (B-A)//2
case3 변수의 차이가 홀수면 (B-A)/2

5 2  7 3  9 4  11
4 2  6 3  8 4  10 5

17319.문자열문자열
딕셔너리 안에 a~z의 키를 생성하고 value값을 0으로 설정한 딕셔너리 생성
value값이 0이 아닌 값들은 모두 2이상이고 서로 값이 같아야 한다
case1 1이라는 값 있으면 No
case2 모든 value값이 같지 않으면 No
나머지 yes

16190. 원 안의 점
2면   x,y의 범위는 -2 <= x, y <= 2
x제곱 + y제곱이 N제곱보다 같거나 작으면 count += 1

16800. 구구단 걷기
10 = 1.10, 2.5
50 = 1.50 2.25 5.10
120 = 1.120, 2.60 3.40. 4.30, 5.24, 6.20, 8.15, 10.12
N을 두수의 곱으로 나타낼 수 있는데 이 두 수의 차이가 가장 적은 값의 자리로 이동
약수를 구한후

16002. 합성수 방정식
n의 차이만큼 for문으로 바교하면서 두 수가 합성수이면 출력
a, b

15941. 평행사변형

15758. 무한 문자열
문자열의 길이가 작은쪽을 먼저 분석
작은 문자열이 더 작은문자열의 반복인지 확인
1)더 작은문자열의 반복이면 큰 문자열도 더 작은문자열의 반복인지 확인
   더 작은문자열의 반복이 아니면 작은 문자열의 반복이 큰 문자열인지 확인
문자열의 길이가 같으면 서로 같은지 확인
-> 너무 어렵게 생각하지 말기..


12851. 숨바꼭질2
시간복잡도 nlogn이하
역으로 접근
동생의 위치가 홀수이면 -1후 count += 1(2로 나누어 떨어져야 하기 때문)
1)앞의 수가 짝수이면 바로 나누기2
2)앞의 수가 홀수이면 -1 후 나누기2

가장빠른 시간으로 동생을 찾는 방법의 수는 최대 2가지


=======================================
백준
=======================================
구슬 탈출 2.골드1
a와 c의 중간값을 설정 -> b가 그 중간값이 되기 위해 필요한 숫자 출력

1260. DFS와 BFS
1)DFS
입접리스트 무방향 그래프
graph for문탐색
1에서 시작
1을 
해당 인덱스에 값이 들어있으면 1을 0으로 바꾸고 탐색 시작

1004. 어린왕자

2006. 바이러스
bfs사용
인접리스트 무방향그래프 활용

2178. 미로탐색 실버1
bfs사용
인접행렬사용

2667. 단지번호붙이기 실버1
bfs사용
인접행렬사용

11724. 연결 요소의 개수
dfs사용
인접리스트사용

2012. 유기농 배추
dfs사용
인접렬려 무방향그래프 사용

2468.
dfs사용
높이 1부터 100까지의 안전지역의 최대 개수를 구한다

1920. 수 찾기
이진 탐색 사용

10816. 숫자카드2
이진 탐색 사용

10828. 스택 실버4
스택

1874. 스택 수열 | 실버2
스택
pop을 할 때 pop하는 수가 전에 나오지 않았으면 NO

1764. 듣보잡 | 실버4
set함수 교집합

10815. 숫자 카드 | 실버5

2002. 추월 | 추월

10845. 큐 | 실버4

1158. 요세푸스 문제 | 실버4

12789. 도키도키 간식드리미 | 실버3
1일 나올떄까지 앞에서부터 번호를 빼서 공간안에 stack으로 쌓아둔다
->스택 하나 생성, 1이 나올때까지 숫자를 뽑아서 스택에 쌓는다
1이 나오면 스택에 쌓지 않고 바로 삭제
다음 숫자의 위치에 따라 case분류
1)다음 숫자가 스택에 있을 경우 - 제일 위에 해당 숫자가 있어야 됨
2)다음 숫자가 deque에 있을 경우 - 다음 숫자가 나올때까지 숫자를 뽑아서
스택에 쌓음, 숫자가 나오면 바로 삭제
반복

2346. 풍선 터뜨리기 | 실버3
덱
rotate함수 사용

11478. 서로 다른 부분 문자열의 개수 | 실버3
set함수로 중복 제거

20920. 영단어 암기는 괴로워 | 실버3

2751. 수 정렬하기 2 | 실버5

1427. 소트인사이드 | 실버5

11650. 좌표 정렬하기 | 실버5

18870. 좌표 압축 | 실버2
set함수로 중복 제거
오름차순 정렬 하면 해당 인덱스 번호가 좌표압축된 값

11659. 구간 합 구하기 4 | 실버4

11660. 구간 합 구하기5 | 실버1
구간합을 미리 구하기

10986. 나머지합 | 골드3

2018. 수들의 합 | 실버5
처음값의 start와 end의 포인터를 설정
start와 end 사이의 값을 모두 더하고 이 값이 N보다 작으면 end를 계속 +1
반복하다가 값이 N이랑 같으면 start += 1 end = start
값이 N보다 커지면 start +=1 end -=1

1940. 주몽 | 실버4

1253. 좋다 | 골드4
투포인터
